// Generated by CoffeeScript 1.3.3
(function() {
  var __slice = [].slice;

  define(['backbone', 'marionette', 'atc/controller', 'atc/models', 'epub/models', 'atc/auth', 'atc/views', 'hbs!gh-book/sign-in-out', 'hbs!gh-book/fork-book-item', 'css!atc'], function(Backbone, Marionette, Controller, AtcModels, EpubModels, Auth, Views, SIGN_IN_OUT, FORK_BOOK_ITEM) {
    var b, defer, readDir, readFile, resetDesktop, uuid, writeFile, _saveContent;
    uuid = b = function(a) {
      if (a) {
        return (a ^ Math.random() * 16 >> a / 4).toString(16);
      } else {
        return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, b);
      }
    };
    defer = function(fn) {
      return function() {
        var args, callback, cb, deferred, _i;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), cb = arguments[_i++];
        deferred = jQuery.Deferred();
        callback = function(err, value) {
          cb(err, value);
          if (err) {
            return deferred.reject(err, value);
          } else {
            return deferred.resolve(value);
          }
        };
        args.push(callback);
        fn.apply(this, args);
        return deferred.promise();
      };
    };
    writeFile = defer(function(path, text, commitText, cb) {
      return Auth.getRepo().write(Auth.get('branch'), "" + (Auth.get('rootPath')) + path, text, commitText, cb);
    });
    readFile = defer(function(path, cb) {
      return Auth.getRepo().read(Auth.get('branch'), "" + (Auth.get('rootPath')) + path, cb);
    });
    readDir = defer(function(path, cb) {
      return Auth.getRepo().contents(Auth.get('branch'), path, cb);
    });
    Backbone.sync = function(method, model, options) {
      var callback, error, id, path, success;
      success = options != null ? options.success : void 0;
      error = options != null ? options.error : void 0;
      callback = function(err, value) {
        if (err) {
          return typeof error === "function" ? error(model, err, options) : void 0;
        }
        return typeof success === "function" ? success(model, value, options) : void 0;
      };
      path = model.id || (typeof model.url === "function" ? model.url() : void 0) || model.url;
      switch (method) {
        case 'read':
          return readFile(path, callback);
        case 'update':
          return writeFile(path, model.serialize(), 'Editor Save', callback);
        case 'create':
          id = _uuid();
          model.set('id', id);
          return writeFile(path, model.serialize(), callback);
        default:
          throw "Model sync method not supported: " + method;
      }
    };
    _saveContent = function() {
      var allContent, recSave;
      allContent = AtcModels.ALL_CONTENT.filter(function(model) {
        return model.hasChanged();
      });
      console.log("Saving " + allContent.length + " files back to github");
      recSave = function() {
        var model, saving;
        if (allContent.length === 0) {
          return AtcModels.ALL_CONTENT.trigger('sync');
        } else {
          model = allContent.shift();
          saving = model.save(null, {
            success: recSave
          });
          if (!saving) {
            console.log("Skipping " + model.id + " because it is not valid");
            return recSave();
          }
        }
      };
      return recSave();
    };
    Views.AuthView = Marionette.ItemView.extend({
      template: SIGN_IN_OUT,
      events: {
        'click #sign-in': 'signIn',
        'click #sign-out': 'signOut',
        'click #save-settings': 'saveSettings',
        'click #save-content': 'saveContent',
        'click #fork-book': 'forkBook'
      },
      initialize: function() {
        var disableSave,
          _this = this;
        this.listenTo(AtcModels.ALL_CONTENT, 'change', function() {
          var $save;
          $save = _this.$el.find('#save-content');
          $save.removeClass('disabled');
          return $save.addClass('btn-primary');
        });
        disableSave = function() {
          var $save;
          $save = _this.$el.find('#save-content');
          $save.addClass('disabled');
          return $save.removeClass('btn-primary');
        };
        this.listenTo(AtcModels.ALL_CONTENT, 'sync', disableSave);
        return this.listenTo(AtcModels.ALL_CONTENT, 'reset', disableSave);
      },
      onRender: function() {
        var _this = this;
        this.$el.find('*[title]').tooltip();
        return this.listenTo(this.model, 'change', function() {
          return _this.render();
        });
      },
      signIn: function() {
        return this.model.set({
          username: this.$el.find('#github-username').val(),
          password: this.$el.find('#github-password').val()
        });
      },
      signOut: function() {
        return this.model.signOut();
      },
      forkBook: function() {
        var $fork, forkHandler;
        if (!this.model.get('password')) {
          return alert('Please log in to fork or just go to the github page and fork the book!');
        }
        $fork = this.$el.find('#fork-book-modal');
        forkHandler = function(org) {
          return function() {
            return Auth.getRepo().fork(function(err, resp) {
              $fork.modal('hide');
              if (err) {
                throw "Problem forking: " + err;
              }
              alert('Thanks for forking!\nThe current repo (in settings) has been updated to point to your fork. \nThe next time you click Save the changes will (hopefully) be saved to your forked book.\nIf not, refresh the page and change the Repo User in Settings.');
              return Auth.set('repoUser', org);
            });
          };
        };
        return Auth.getUser().orgs(function(err, orgs) {
          var $item, $list;
          $list = $fork.find('.modal-body').empty();
          $item = this.$(FORK_BOOK_ITEM({
            login: Auth.get('username')
          }));
          $item.find('button').on('click', forkHandler(null));
          $list.append($item);
          _.each(orgs, function(org) {
            $item = this.$(FORK_BOOK_ITEM({
              login: "" + org.login + " (Organization)"
            }));
            $item.addClass('disabled');
            return $list.append($item);
          });
          return $fork.modal('show');
        });
      },
      saveSettings: function() {
        var rootPath;
        rootPath = this.$el.find('#github-rootPath').val();
        if (rootPath && rootPath[rootPath.length - 2] !== '/') {
          rootPath += '/';
        }
        return this.model.set({
          repoUser: this.$el.find('#github-repoUser').val(),
          repoName: this.$el.find('#github-repoName').val(),
          branch: this.$el.find('#github-branch').val(),
          rootPath: rootPath
        });
      },
      saveContent: function() {
        return _saveContent();
      }
    });
    resetDesktop = function() {
      return EpubModels.EPUB_CONTAINER.loaded().then(function() {
        AtcModels.SearchResults = AtcModels.SearchResults.extend({
          initialize: function() {
            var model, _i, _len, _ref, _results;
            _ref = AtcModels.ALL_CONTENT.models;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              model = _ref[_i];
              if (model.get('mediaType') !== 'text/x-module') {
                _results.push(this.add(model, {
                  at: 0
                }));
              } else {
                _results.push(this.add(model));
              }
            }
            return _results;
          }
        });
        return Controller.start();
      });
    };
    Auth.set('password', prompt('Enter password'));
    return resetDesktop();
  });

}).call(this);
